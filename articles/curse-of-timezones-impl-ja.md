---
title: "タイムゾーン呪いの書 (実装編)"
emoji: "🌏" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ "timezone", "tzdb" ]
layout: default
published: false
---

「時刻」の技術
===============

時刻というこの厄介な概念について話を続けるときりがないのですが、ここまでである程度は概観できたと思います。時刻は複雑で、「こうやっておけば大丈夫」と言えるような唯一の正解はなさそうです。適切な扱い方は要件によって違うものになるでしょう。

それでも、要件を整理しながら個々に対抗策を考えることはできます。ここからは、Java 8から導入されたJSR 310（java.time）のクラス群を例として参照しながら、設計時に気をつけるべきことを考えてみます。JSR 310については、あとの節で詳しく扱います。

内部データ表現
---------------

ソフトウェアで時刻をどう保持するかは、次の3点から考えるといいでしょう。

* 保持している時刻が時間軸上の1点に対応しなくなるあいまいさがあえて必要か
* 時刻の切り替わりをまたぐ計算をするか
* 地理ベースの情報が必要な要件か

以下、細かい検討内容を見てみます。

### 閏秒を直接扱う必要があるか？ 秒以下の精確さが必要か？

まず考えるのは閏秒です。銀行などでは閏秒を厳密に扱う必要があるかもしれませんが、一般向けのWebサービスで必要なことは多くないでしょう。閏秒は、どうにかごまかせないかをまず検討しましょう。1秒の長さが厳密でなくともよければ前述のLeap Smearがそのまま使えるかもしれませんし、秒未満の時間が不要なら逆進を考慮せずに「59分59秒」に2秒間をかけてもいいかもしれません。経過時間をはかるだけなら、時刻よりタイマーのほうが適切です。ごまかす場合、どうごまかすのか仕様として明記しましょう。

閏秒さえごまかせるなら、内部表現として Unix time を使う案は最初に検討する価値があります。閏秒を除けば解釈にあいまいさがなく、使うメモリも少なく、単純な計算は非常に簡単に行えます。たとえば、イベント発生時刻の記録などには充分なはずです。注意点として Unix time の数値を数値型でそのまま保持すると、時差の計算で混乱しがちです。 JSR 310 の `Instant` のような専用のクラスを使うと混乱を減らせるでしょう。

ただし Unix time も万能ではありません。詳しくは後述しますが、うるう秒を無視できても Unix time が適さないケースもあります。

うるう秒を扱うと一気にたいへんになります。 Unix time は使えなくなりますし、そもそも閏秒を扱えるライブラリは多くありません。たとえば JSR 310 も、単体では充分に閏秒を扱えません。どうしてもうるう秒を扱わなければならない場合、それでも任せられるかぎりライブラリに任せましょう。 Java の場合は JSR 310 と ThreeTen-Extra((https://www.threeten.org/threeten-extra/)) というライブラリの併用で、ある程度カバーできます。 ThreeTen-Extra はもともと JSR 310 の一部として検討されていたものですが、仕様が肥大化したため、外部ライブラリとして切り出して整理されたものです。

### 暦の計算をするか？

「翌日」や「その月の最終営業日」のような暦の計算が必要なことがあります。そんなときはタイムゾーンのことを考えないわけにはいきません。夏時間などの時刻の切り替わりをまたぐ可能性があります。まず必要なのは、たとえば要求が「翌日」なら、それが「24時間後（閏秒を無視できれば86,400秒後）」でいいのか「次の日の同じ時刻」なのか明確にすることです。そして「次の日の同じ時刻」になりそうなら、それは本当に必要なのか再検討しましょう。

「次の日の同じ時刻」までの時間は、夏時間を考慮すると 23時間かも 24時間かも 25時間かもしれません。 Unix time では計算しづらいため、少なくとも地理ベースのタイムゾーンと日付、時分秒を組み合わせて表現する必要がありますが、それだけではありません。「存在しない時刻」「二重に存在する時刻」もあるため、地理ベースのタイムゾーンだけでは情報が失われてしまいます。たとえば `"2018-11-03 01:30:00"` の「次の日の同じ時刻」である `"2018-11-04 01:30:00"` は、標準時なのか夏時間なのか `"America/Los_Angeles"` だけでは判断できません。

`"-07:00"` のようなオフセットも同時に保持しておけば、少なくとも情報の喪失は防ぐことができます。 JSR 310 の `ZonedDateTime` は地理ベースのタイムゾーンと同時にオフセットも保持できるので、助けになるでしょう。しかし、切り替わりによる不整合の扱いは要件しだいです。各ケースを検討して、早いほうに寄せる、エラーにする、ズレや重複を許容する、など要件に合った対応を自分たちで決めなければなりません。極端な場合、サモアのように「次の日」が存在しない例さえあります。

「24時間後」で済むなら、タイムゾーンを考慮する必要が激減します。 Unix time を採用して単純化できるかもしれません。日付や時分秒を頻繁に扱うなら日時を使う案もまだ有力ですが、タイムゾーンとしてオフセットのみを使えば十分なことも多いでしょう。

### 現地時刻や、その時刻の場所は重要か？

どこで起きること・起きたことの時刻か、が重要なことがあります。たとえば店舗の営業時間は、一般的には現地時刻で表します。飛行機の出発・到着時刻は、それぞれ出発地と到着地の現地時刻です。

将来のイベントの予定が現地時刻で決まっているかもしれません。このような場合に Unix time に変換してしまうと、痛い目を見ることがあります。たとえば、近く夏時間を導入するかもしれない国で 2年後の 7月24日に予定されているイベントの開始時刻が、現地時刻で決まっていたとします。[^tokyo-olympic] その開始時刻を現時点の tz database を使って Unix time に変換してしまうと、夏時間がそれまでに導入された場合、実際の開始時刻と変換後の Unix time がずれてしまいます。

[^tokyo-olympic] [アレ](@@@2020)ですね。

起きたことの記録としての過去の時刻は、直感的には UTC や Unix time で残ってさえいればいいように思えます。しかし、人間は現地時刻で解釈します。たとえば、@@@夏時間に入る前の病院のカルテの記録時刻を夏時間に入ったあとに医師が見返したとき、その時刻を夏時間に入る前の現地時刻として解釈したいのが普通でしょう。

こんなときは時刻をタイムゾーンと一緒に持ち回る必要がありますが、持ち回るタイムゾーンの形式も問題です。選択肢は、オフセットのみを持つ、地理ベースのタイムゾーンのみを持つ、両方を持つ、の3つです。将来のイベントの例では、時刻にオフセットを持つと逆に困ったことになるので、地理ベースのタイムゾーンのみ保持するのがよさそうです。カルテの例では、オフセットだけ持てば記録としては十分そうですが、「この記録から何時間後」のような計算をするなら、一緒に地理ベースのタイムゾーンも必要かもしれません。

ただし、地理ベースのタイムゾーンを扱うときは常に前述の問題を頭に入れておかなければなりません。オフセットで済むなら時刻は常に Unix time に変換でき、簡単にできます。これは、時刻とタイムゾーンを扱うときは常に考えなければならないトレードオフです。

### タイムゾーンの表現

地理ベースのタイムゾーンが必要なときは、前述の tzdb を基本とするといいでしょう。 JSR 310 では `ZoneId` クラスが対応します。

@@@データの出力・永続化・受け渡し
---------------------------------

時刻データの永続化や他のコンポーネントとの受け渡しの際にも、考えることは同様です。ただし、永続化したデータや受け渡したデータは関わる人が増えるので、次の点に気をつけると混乱を減らせます。

* Unix timeで済む場合はUnix timeを使うことを検討する
* 省略する必要がない限り、タイムゾーン情報を省略しない。常にUTCと決めている場合でも明示的にUTCと付ける
* オフセットを確定できる場合は常にオフセットを付ける

### 時刻の文字列表現

JSON などに入れるために文字列にする際は、みんなが同じ形式を使うとみんなが楽です。国際規格の ISO 8601 に従った `"20181031T123456+0900"` や `"2018-10-31T12:34:56+09:00"` のような形式がよく使われます。 JSR 310 も ISO 8601 を強く意識して作られていて、扱いやすくなっています。

ただし ISO 8601 には地理ベースのタイムゾーンに関する仕様は含まれていません。 JSR 310 は `"2018-10-31T12:34:56+09:00[Asia/Tokyo]"` のように表記を拡張しています。

くどいですが、地理ベースのタイムゾーンを出力する場合 `JST` などのあいまいな略称は使わないようにしましょう。

データの入力
-------------

### 現在時刻の取得

現在時刻を取得して使うだけなら単純に済むことは多いですが、通信が関係する場合は「通信対象（たとえばブラウザ）が認識する時刻・タイムゾーン」と「今書いているコードが動く環境の時刻・タイムゾーン」のどちらを扱いたいのか・扱っているのかを明確にしましょう。<!--これじゃ分散システムの話っぽい…-->

### 外部データソースからの入力

自分で永続化したデータは設計したとおりに読み込めるはずですが、読み込むのはそればかりではありません。

読み込む時刻が文字列の場合、前述の ISO 8601 に従っていれば簡単ですが、そうでないこともあります。ありがちな問題としては、アメリカの慣習に従って年月日を「月日年」で並べた CSV のデータが来るかもしれません。

また、前述した `"JST"` のようなあいまいな略称が使われてしまうこともあります。その場合は決め打ちするしかありません。どうしても略称を読み込む必要がある場合は、「“JST”は“Asia/Tokyo”として扱う」など、対応関係を仕様として明確化しておきましょう。

JSR 310 の `ZoneId` はおもに tzdb 名を使ってインスタンス化するのですが、インスタンス化の際に別名の `Map` を与えることができます。たとえば `"JST"` を `"Asia/Tokyo"` に対応させる `Map` を用意しておけば、それを使って `"Asia/Tokyo"` と同等の `ZoneId` を `"JST"` から生成することもできます。

### ユーザからの入力

ユーザが過去や未来の時刻を手で入力する場合、その時刻がどの地域、どのオフセットのものかが問題になります。まずは要件からユーザの意図を検討しなければなりません。とくに未来の時刻を入力する場合、ユーザは前述のイベントの例のように「将来ずれるかもしれない現地時刻」を指定したいのか、「将来もずれない絶対時刻」を指定したいのか、要件によって異なるでしょう。

ユーザが想定するタイムゾーンを特定する方法はいくつか考えられます。大きく分けると、時刻と一緒に手で入力してもらう、事前にアカウントなどに設定しておいてもらう、ユーザが@@@physically@@@「今いる」タイムゾーンを使う、の3つになるでしょう。

手で入力してもらうのは煩雑ですが確実です。限定された「わかっている」ユーザが対象の場合や、間違いが許されない重要な設定の場合は、有力な選択肢になります。また、手入力以外を採用した場合でも、最後の手段として手で編集する余地を残す案もあります。

アカウントなどに設定しておいてもらう方法は、もちろんアカウントなどに設定を保存できるシステムであることが大前提です。そのうえで、ユーザが他のタイムゾーンに移動したときに、設定の追従を忘れる可能性も考慮に入れなくてはならないでしょう。手で入力をさせないまでも「今あなたが入力しようとしているのは東京時間です」とわかる表示をすると、間違いを減らせるかもしれません。

ユーザが「今いる」タイムゾーンを使うのは意外と厄介です。まず、ユーザが本当に今いる場所の時刻を意図しているのかは、自明ではありません。そして「今いる」タイムゾーンを取得する方法も技術的に確実ではありません。スマートフォンのアプリなどなら取得しやすいですが、とくにPCは場所を正確に反映しているとは限りません。

Time Zone Databaseの更新
-------------------------

tzdb は新しい版が頻繁にリリースされます。古い版の tzdb を使っていると、地域によって時刻の解釈がおかしくなってしまい、それが致命的な問題を引き起こすこともあるでしょう。

ネイティブアプリケーションやライブラリの開発は tzdb のバージョン管理とは独立ですが、オンラインサービスの運用はそうもいきません。サモアのように大きな変更が直前に入ることがあると考えると、コーディング以外に tzdb 更新の戦略もしっかり立てておかなければなりません。いま作っているソフトウェアがどこの tzdb を参照していて、なにを更新すれば tzdb が更新されるのかを把握しておきましょう。

Javaで使われるtzdbはJava Runtimeの各バージョンに付属します。
