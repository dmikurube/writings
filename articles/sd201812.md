泥沼にはまらないための「時刻」の歩き方

三廻部 大 (みくるべ だい), トレジャーデータ株式会社

ソフトウェア開発のとき、時刻の扱いにどのような方針を採っていたでしょうか。タイムゾーン、閏秒、そして夏時間。複雑に関係する時刻のしくみと基礎をいま一度確認し、要件に合った設計ができるようにポイントをおさえておきましょう。

----

夏時間の話題で多くのエンジニアが沸いた夏になりましたね。無謀に思えた2020年導入の話は幸い断念されましたが、それはそれとして、ソフトウェアで時刻処理をまともに実装しておくに越したことはありません。将来的に夏時間が導入されてしまう可能性もありますし、そのソフトウェアを日本国外に展開するチャンスが来ても、間違った時刻処理が障壁となってしまったら悲しいことです。

本章は、一度間違えると継続して「呪われて」しまいがちな時刻の罠を避けるために、時刻とタイムゾーンという概念の成り立ちとしくみから、「呪い」を避けるための工夫を紹介します。

時刻とは何か？ タイムゾーンとは何か？
====================================

「午後1時といえば昼ごろだよね」という認識を世界中で共有したければ、地球に住む限り「時差」からは逃げられません。ある地域でいう「午後1時」はその地域である瞬間を表す「時刻」ですが、同じ瞬間に「午前9時」の地域もあります。これがややこしさの元凶であり、出発点です。

とはいえ、たとえば東西に少しだけ離れた品川と永田町と新宿の間にも時差があったら、生活も会話も困難です。そこで地理的・社会的に近い地域では共通の時刻を使うことにしています。その共通の時刻をその地域の「標準時」と呼び、同じ標準時を使う地域を「タイムゾーン」と呼びます。たとえば、いわゆる日本標準時を使う「日本」が、1つのタイムゾーンです。

タイムゾーン境界の多くは、国境や国内の政治境界に準じます。生活上便利ですし、標準時は「この地域ではこの標準時を使う」と国や地域が宣言して決まっているだけだからでもあります。タイムゾーンの境界を国際条約などで決めているわけではないのです。

タイムゾーンの定義と実際の用法
-------------------------------

前述のとおり「タイムゾーン」は標準時をもとに定義されます。標準時は夏時間とは独立した概念で、たとえばアメリカのユタ州とアリゾナ州は同じ「山岳部標準時」を使いますが、夏時間制には差があります。この2州は、定義上は同じタイムゾーンです。

しかし「タイムゾーン」という言葉は、実態としては多様な使われ方をしています。ユタ州とアリゾナ州を別のタイムゾーンと呼ぶ例も多く見られます。逆に異なる「標準時」の国でも同等の時刻を使っていれば、まとめて1つのタイムゾーンと呼ぶ例もあります。後述する“UTC+9”などの、特定の時差の時刻系そのものをタイムゾーンと呼ぶこともあります。

タイムゾーンの基準：UTCと閏((うるう))秒
-------------------------------

各地域間の相対的な時差だけで多くの時刻を扱うのはたいへんです。基準がないと混乱してしまいます。

初期に国際的な基準として使われたのが、グリニッジ標準時（GMT：Greenwich Mean Time）です。GMTは地球の自転に基づく時刻で日常生活には有用ですが、自転の周期はふらつきがあり、厳密な24時間とは一致しません。GMTを継承して数種類の世界時（UT：Universal Time）が定義されましたが、やはり自転に基づきます。

逆に、地球の自転によらず原子時計をもとに定めた時刻が国際原子時（TAI：Temps Atomique International）です。こちらは厳密な1秒を刻みますが、地球の1周とTAIの1日にはずれが生じます。

1日・1秒の長さが変わるのも、1日と地球の1周がずれるのも、どちらも不便です。そこで協定世界時（UTC：Coordinated Universal Time）として折衷案というべき時刻系が提案され、多くの分野で基準として採用されています。UTCは、原子時計で1秒を刻みつつも、自転に基づくUT（UT1）との差が0.9秒を超えないように、閏((うるう))秒を導入しながら調整を続けている時刻系です。閏秒は面倒で嫌われがちですが、どれかの不便は受け入れないとならないのです。

^ TODO: 閏((うるう))秒を挿入→導入が未反映。

ちなみに閏秒は「60秒」が挿入される「正の閏秒」だけではなく、「59秒」が削除される「負の閏秒」が実施される可能性もあります。ただし実施例は現在までに一度もありません。

情報通信分野ではおもにUTCが使われ、またGMTはUTCと同等に扱われることが多いです。

時差はUTCからの差で表現され、たとえばUTCから9時間進んだ日本の時刻は“UTC+9”、“UTC+09:00”、“+09:00”などと表記します。多くのタイムゾーンはUTCから1時間単位の差ですが、オーストラリア中部標準時（UTC+09:30）やネパール標準時（UTC+05:45）のようなタイムゾーンも存在します。

時刻の切り替わり
-----------------

ある地域の時刻が別の時刻に切り替わることがあります。代表例が夏時間です。

### 夏時間

地域間の時差だけでもたいへんなのに、同じ地域で時刻がずれるのが夏時間です。明るいうちに余暇を長く過ごせるように実施されるので、夏時間に切り替わるとき、その地域では少し時刻が進みます。そのとき、時刻がいきなり飛ぶ形で進むことに注意が必要です。

たとえば2018年のアメリカ合衆国の場合は3月11日（日）に夏時間に切り替わりました。そのタイミングは、切り替わる前の時刻でいう午前2時で、この日の午前1時59分59秒から1秒経ったと思ったら、午前3時0分0秒になっていた、という具合です。カリフォルニア州を例に、経過を1秒ごとに並べると次のようになります。

| カリフォルニア州の時刻 | UTCからの時差 |
| --- | --- |
| 2018-03-11 01:59:58 | 太平洋標準時 -08:00 |
| 2018-03-11 01:59:59 | 太平洋標準時 -08:00 |
| 2018-03-11 03:00:00 | 太平洋夏時間 -07:00 |
| 2018-03-11 03:00:01 | 太平洋夏時間 -07:00 |

逆に夏時間から標準時に戻るときは、一見すると同じ時刻を2度経験することになります。カリフォルニア州の例では次のようになります。

| カリフォルニア州の時刻 | UTCからの時差 |
| --- | --- |
| 2018-11-04 01:00:00 | 太平洋夏時間 -07:00 |
| 2018-11-04 01:00:01 | 太平洋夏時間 -07:00 |
| … | … |
| 2018-11-04 01:59:59 | 太平洋夏時間 -07:00 |
| 2018-11-04 01:00:00 | 太平洋標準時 -08:00 |
| 2018-11-04 01:00:01 | 太平洋標準時 -08:00 |

### 夏時間よもやま話 <!-- ここは囲み記事 (コラム?) のようにしてもらうといいかと思っています -->

- 日本では現在は実施されていませんが、第二次大戦後に数年間実施されたことがあります。
- 夏時間でずれるのは1時間とは限りません。現在でも、オーストラリアのLord Howe島では30分ずれる夏時間制が実施されています。
- 過去には2時間ずれる夏時間が実施された国もあります。おもに大戦中、前年の夏時間から戻らないまま二重にずらしたイギリスや、同年中に段階的に2時間ずらしたドイツなどです。
- アメリカ方面ではDaylight Saving Timeと、欧州（とくにイギリス）ではSummer Timeと呼ばれます。
- ブラジルでは夏時間の実施地域や切り替え日が2008年まで毎年個別に公示されていて、公示が開始の直前になったこともあるようです。
- チリでは近年頻繁に夏時間制に変更があり、安定していないようです。

### 夏時間以外の切り替わり

夏時間以外にも、国や地域の政治的決定により時刻が切り替わることがあります。

たとえば2011年の年末には、サモア独立国の標準時が“UTC-11”から“UTC+13”に切り替わりました。この切り替わりは12月29日の終わりがそのまま12月31日の始まりに続く形で行われ、サモアでは2011年12月30日がなかったことになりました。

夏時間制は一定の規則のもと定例で実施されることが多いですが、このサモアのような非定例の切り替わりも、意外と頻繁にあります。時刻を扱うには、その変更にも追いつかないとならないのです。

情報通信分野における時刻
=========================

ここまで時刻のしくみ一般を説明してきました。ここからは、情報通信分野特有の内容に入っていきます。

Unix time：世界共通の時間軸
----------------------------

「時刻」には各地で違いがありますが、それでも時間軸は世界共通で、その時間軸上の1点は世界中で同時に訪れます。たとえば日本の2018年7月1日午後3時0分0秒とイギリスの2018年7月1日午前7時0分0秒は、同じ瞬間です。1つのタイムゾーン内ではそこの時刻を使えば済みますが、タイムゾーンをまたぐ場合、とくにインターネットが関わる場合、世界共通の時間軸で考えたくなります。

要はUTCで考えればいいのですが、年月日時分の繰り上げなどを毎回計算するのは無駄です。そこで情報通信分野では、よくUnix timeを流用して時刻を表現します。

Unix timeは、日本語ではUNIX時間、英語ではPOSIX timeまたはUNIX Epoch timeなどとも呼ばれ、時刻をUTCの1970年1月1日 0時0分0秒（Epoch）からの経過秒で表現します。

<!-- 1972/1/1以前のUnix time -->
<!-- https://en.wikipedia.org/wiki/Unix_time#History -->

Unix timeがわかっていれば、任意のタイムゾーンにおける時刻を簡単に計算できるはず…ですが、残された問題が閏秒です。閏秒は自転速度のふらつきを埋めるしくみなので、未来の何年に閏秒が挿入されるかはなかなか確定できません。そのため閏秒を考慮に入れると、未来の時刻に対応するUnix timeが計算できません。

そこでUnix timeは経過時間としての厳密さを捨てて利便性を優先し、閏秒を無視することになりました。最近ではUTCにおける2016年12月31日 23時59分59秒と2017年1月1日 0時0分0秒の間に閏秒が挿入されましたが、このときUnix timeの1483228800は2秒間続きました。その経過を0.5秒ごとに並べると次のようになります。

| UTCにおける時刻 | Unix time |
| --- | --- |
| 2016-12-31 23:59:59.00 | 1483228799.00 |
| 2016-12-31 23:59:59.50 | 1483228799.50 |
| 2016-12-31 23:59:60.00 | 1483228800.00 |
| 2016-12-31 23:59:60.50 | 1483228800.50 |
| 2017-01-01 00:00:00.00 | 1483228800.00 |
| 2017-01-01 00:00:00.50 | 1483228800.50 |
| 2017-01-01 00:00:01.00 | 1483228801.00 |

秒の整数部だけ見ると同じ秒が2秒続くだけに見えますが、小数部の扱いに気をつける必要があります。小数部は普段どおりにカウントするため、小数部も含めて見ると時刻が逆進したことになるからです。

### UTC-SLS と Leap Smear

情報通信業界のすべての仕事で、閏秒を導入してまで厳密な1秒が必要なわけではありません。Unix timeにおける逆進も含め、閏秒は多くの問題を起こしてもきました。

そこで必要なさそうな場合は1秒の厳密さを捨てて、閏秒を周辺の数時間で「希釈」する手法が生まれました。これは最近のクラウドサービスで"Leap Smear"と呼ばれ、一般的になりつつあります。

このような手法が公開の場で議論されたのは、ケンブリッジ大学のMarkus Kuhn氏による2000年のUTS（Smoothed Coordinated Universal Time）と、そこから派生して2006年にIETF Internet Draftとして公開されたUTC-SLS（Coordinated Universal Time with Smoothed Leap Seconds）が最初のようです。UTC-SLSでは閏秒が導入される日の最後の1,000秒に均等に閏秒を分散させ、閏秒をなくしてしまいます。

(TODO: まず上記を適用してみてください)

Googleが2008年に実施した最初のLeap SmearはUTS-SLSと異なり、閏秒前の20時間に非線形に分散させるものでした。その後2012年、2015年、2016年に実施したLeap Smearは、閏秒を中心とする20時間に線形に分散させるものになったようです。その後Googleは24時間に分散させるやり方を標準とすることを提案しています。Amazonが2015年と2016年に実施したLeap Smearも、同様に24時間に分散させるものでした。クラウドサービスのLeap Smearは、おもにNTPを介して提供されています。

(TODO: 前々段落の変更で足らなければ、上の段落の変更を入れてみてください。最後の文は入れても削っても大丈夫です)

<!--
もしfootnoteなどで参照を貼るようであれば:
UTC-SLS: https://tools.ietf.org/html/draft-kuhn-leapsecond-00
Google: https://developers.google.com/time/smear
AWS: https://aws.amazon.com/jp/blogs/news/look-before-you-leap-december-31-2016-leap-second-on-aws/
-->

タイムゾーンの業界標準と注意点
-------------------------------

### Time Zone Database

情報通信分野でタイムゾーンに関する最も標準的なデータがTime Zone Database（tzdb）[^1]でしょう。ほかにzoneinfo databaseや、主要な貢献者の名前をとってOlson databaseと呼ばれることもあります。“Asia/Tokyo”や“Europe/London”のような名前は、このtzdbのものです。tzdbのタイムゾーン名は、最初の“/”の前に大陸・海洋名を、後ろにそのタイムゾーンを代表する都市名・島名などを用いて付けられます。

[^1]: https://www.iana.org/time-zones

世の中のタイムゾーンは頻繁に変わるため、年に数回は新しい版のtzdbがリリースされます。夏時間のような定例ルールから、非定例の切り替わり、閏秒の情報まで、さまざまな情報を含むことを目標に、ボランティアでメンテナンスが続けられています。tzdbが更新されるとOSやJavaなどの処理系、ライブラリなどがそれぞれ更新を取り入れ、それぞれのアップデートとして配信します。

ソフトウェアで地理的なタイムゾーンを扱う場合、できるだけtzdb名で扱うのがいいでしょう。後述するようにほかの表現には問題が多いです。

ただし、tzdbの更新は余裕をもって行われるとは限りません。更新方針をあらかじめ立てておく必要があります。たとえば前述のサモアの変更がtzdbに適用されたのは、サモア標準時が実際に変わる2011年12月のわずか4ヵ月前でした。

### 3文字／4文字の略称

日本標準時（Japan Standard Time）は、しばしば“JST”と略されます。しかしtzdbのコメントには、エルサレム標準時（Jerusalem Standard Time）を“JST”としている例もあります。“JST”のような略称は一見使いやすいのですが、このように、実はタイムゾーンを一意に特定できるとは限りません。

このような略称は使用しないほうがいいでしょう。日本で“JST”を使って動いていたシステムが、国外に展開したらデータがおかしくなるようになった、というようなことが起こりえます。

地理的なタイムゾーンを扱う必要がある場合はtzdb名を使い、略称を使ったデータは、少なくとも保存しないようにしましょう。

### 北米タイムゾーンの略称

標準ではほとんどの3文字略称を扱えないようになっていても、北米タイムゾーンの略称“EST”“EDT”“CST”“CDT”“MST”“MDT”“PST”“PDT”だけは特別に扱える処理系やライブラリがあります。RFC 822などの標準に、これらの記載が含まれていたためのようです。

それでもこれらの略称の使用は避けたほうがいいでしょう。実装によって扱いに微妙な違いがあり、混乱を招くかもしれません。

たとえばRubyのTime.strptimeは、標準時の“PST”を常に“-08:00”として、夏時間の“PDT”を常に“-07:00”として扱います。夏時間実施中の日時に“PST”をつけた“2018-07-01 12:34:56 PST”は、標準時の“2018-07-01 12:34:56 -08:00”として解釈されます。

しかしJavaのライブラリのJoda-Timeでは微妙に異なります。Joda-Timeの一部のメソッドは“PST”と“PDT”の両方を“America/Los_Angeles”と同等に扱います。つまり“2018-07-01 12:34:56 PST”が“2018-07-01 12:34:56 -07:00”と解釈される、ということです。

### Military time zones

“Z”の1文字で“UTC”を表す記述を見たことがある人は多いと思います。これはおもに米軍で使われる“Military time zones”から来ています。“UTC-12”から“UTC+12”までの25のタイムゾーンに、大文字のアルファベット（“J”を除く）を対応させます。

これもRFC 822などに記載があり、標準で扱えるライブラリは多いです。しかし“Z”以外は、やはり使用を避けたほうがいいでしょう。

その第一の理由は、初期のRFCの記述に誤りがあったことです。その誤りのため、異なる扱い方をしていた実装が歴史的にいくつかあり、後にRFC 2822で扱いが変わっています。ほかにも“UTC+13”や“UTC+09:30”のように扱えないタイムゾーンがあることや、有名な“Z”以外はあまり知られていないことなど、使用を避けるべき理由はいくつか挙げられます。

<!-- (TODO: IATA, Microsoft) -->

「時刻」の技術
===============

時刻というこの厄介な概念について話を続けるときりがないのですが、ここまでである程度は概観できたと思います。時刻は複雑で、「こうやっておけば大丈夫」と言えるような唯一の正解はなさそうです。適切な扱い方は要件によって違うものになるでしょう。

それでも、要件を整理しながら個々に対抗策を考えることはできます。ここからは、Java 8から導入されたJSR 310（java.time）のクラス群を例として参照しながら、設計時に気をつけるべきことを考えてみます。JSR 310については、あとの節で詳しく扱います。

内部データ表現
---------------

ソフトウェアで時刻をどう保持するかは、次の3点から考えるといいでしょう。

* 保持している時刻が時間軸上の1点に対応しなくなるあいまいさがあえて必要か
* 時刻の切り替わりをまたぐ計算をするか
* 地理ベースの情報が必要な要件か

以下、細かい検討内容を見てみます。

### 閏秒を直接扱う必要があるか？ 秒以下の精確さが必要か？

まず考えるのは閏秒です。銀行などでは閏秒を厳密に扱う必要があるかもしれませんが、一般向けのWebサービスで必要なことは多くないでしょう。閏秒は、どうにかごまかせないかをまず検討しましょう。1秒の長さが厳密でなくともよければ前述のLeap Smearがそのまま使えるかもしれませんし、秒未満の時間が不要なら逆進を考慮せずに「59分59秒」に2秒間をかけてもいいかもしれません。経過時間をはかるだけなら、時刻よりタイマーのほうが適切です。ごまかす場合、どうごまかすのか仕様として明記しましょう。

閏秒さえごまかせるなら、内部表現としてUnix timeを使う案は最初に検討する価値があります。解釈にあいまいさがなく、使うメモリも少なく、単純な計算は非常に簡単に行えます。たとえばイベント発生時刻の記録などには充分なはずです。ただしUnix timeの数値を数値型でそのまま保持すると、時差の計算で混乱しがちです。JSR 310のInstantのような専用のクラスを使うと混乱を減らせるでしょう。

閏秒を扱うと一気にたいへんになります。Unix timeは使えなくなりますし、そもそも閏秒を扱えるライブラリは多くありません。たとえばJSR 310も単体では充分に閏秒を扱えません。とはいえ、どうしても閏秒を扱わなければならない場合、任せられるかぎりライブラリに任せましょう。Javaの場合はJSR 310とThreeTen-Extra((https://www.threeten.org/threeten-extra/))というライブラリの併用で、ある程度カバーできます。ThreeTen-ExtraはもともとJSR 310の一部として検討されていたものですが、仕様が肥大化したため、外部ライブラリとして切り出して整理されたものです。

### 暦の計算をするか？

「翌日」や「その月の最終営業日」のような暦の計算が必要なことがあります。そんなときはタイムゾーンのことを考えないわけにはいきません。夏時間などの時刻の切り替わりをまたぐ可能性があります。まず必要なのは、たとえば要求が「翌日」なら、それが「24時間後（閏秒を無視できれば86,400秒後）」でいいのか「次の日の同じ時刻」なのか明確にすることです。そして「次の日の同じ時刻」になりそうなら、それは本当に必要なのか再検討しましょう。

「次の日の同じ時刻」までの時間は、夏時間を考慮すると23時間かも24時間かも25時間かもしれません。Unix timeでは計算しづらいため、少なくとも地理ベースのタイムゾーンと日付、時分秒を組み合わせて表現する必要がありますが、それだけではありません。「存在しない時刻」「二重に存在する時刻」もあるため、地理ベースのタイムゾーンだけでは情報が失われてしまいます。たとえば“2018-11-03 01:30:00”の「次の日の同じ時刻」である“2018-11-04 01:30:00”は、標準時なのか夏時間なのか“America/Los_Angeles”だけでは判断できません。

“-07:00”のようなオフセットも同時に保持しておけば、少なくとも情報の喪失は防ぐことができます。JSR 310のZonedDateTimeは地理ベースのタイムゾーンと同時にオフセットも保持できるので、助けになるでしょう。しかし、切り替わりによる不整合の扱いは要件しだいです。各ケースを検討して、早いほうに寄せる、エラーにする、ズレや重複を許容する、など要件に合った対応を自分たちで決めなければなりません。極端な場合、サモアのように「次の日」が存在しない例さえあります。

「24時間後」で済むなら、タイムゾーンを考慮する必要が激減します。Unix timeを採用して単純化できるかもしれません。日付や時分秒を頻繁に扱うなら日時を使う案も有力ですが、タイムゾーンとしてオフセットのみを使えば十分なことも多いでしょう。

### どこの時刻か、が重要か？

どこで起きること・起きたことの時刻か、が重要なことがあります。たとえば店舗の営業時間は、一般的には現地時刻で表します。飛行機の出発・到着時刻は、それぞれ出発地と到着地の現地時刻です。

将来のイベントの予定が現地時刻で決まっているかもしれません。たとえば、近く夏時間を導入するかもしれない国で2年後の7月24日に予定されているイベントの開始時刻が、現地時刻で決まっていたとします。その開始時刻を現時点のtzdbを使ってUnix timeに変換してしまうと、夏時間がそれまでに導入された場合、実際の開始時刻と変換後のUnix timeがずれてしまいます。

起きたことの記録としての過去の時刻は、直感的にはUTCやUnix timeで残ってさえいればいいように思えます。しかし、人間は現地時刻で解釈します。たとえば、夏時間に入る前の病院のカルテの記録時刻を夏時間に入ったあとに医師が見返したとき、その時刻を夏時間に入る前の現地時刻として解釈したいのが普通でしょう。

こんなときは時刻をタイムゾーンと一緒に持ち回る必要がありますが、持ち回るタイムゾーンの形式も問題です。選択肢は、オフセットのみを持つ、地理ベースのタイムゾーンのみを持つ、両方を持つ、の3つです。将来のイベントの例では、時刻にオフセットを持つと逆に困ったことになるので、地理ベースのタイムゾーンのみ保持するのがよさそうです。カルテの例では、オフセットだけ持てば記録としては十分そうですが、「この記録から何時間後」のような計算をするなら、一緒に地理ベースのタイムゾーンも必要かもしれません。

ただし、地理ベースのタイムゾーンを扱うときは常に前述の問題を頭に入れておかなければなりません。オフセットで済むなら時刻は常にUnix timeに変換でき、簡単にできます。これは、時刻とタイムゾーンを扱うときは常に考えなければならないトレードオフです。

### タイムゾーンの表現

地理ベースのタイムゾーンが必要なときは、前述のtzdbを基本とするといいでしょう。JSR 310ではZoneIdクラスが対応します。

データの出力・永続化・受け渡し
-------------------------------

時刻データの永続化や他のコンポーネントとの受け渡しの際にも、考えることは同様です。ただし、永続化したデータや受け渡したデータは関わる人が増えるので、次の点に気をつけると混乱を減らせます。

* Unix timeで済む場合はUnix timeを使うことを検討する
* 省略する必要がない限り、タイムゾーン情報を省略しない。常にUTCと決めている場合でも明示的にUTCと付ける
* オフセットを確定できる場合は常にオフセットを付ける

### 時刻の文字列表現

JSONなどに入れるために文字列にする際は、みんなが同じ形式を使うとみんなが楽です。国際規格のISO 8601に従った“20181031T123456+0900”や“2018-10-31T12:34:56+09:00”のような形式がよく使われます。JSR 310もISO 8601を強く意識して作られていて、扱いやすくなっています。

ただしISO 8601には地理ベースのタイムゾーンに関する仕様は含まれていません。JSR 310は“2018-10-31T12:34:56+09:00[Asia/Tokyo]”のように表記を拡張しています。

くどいですが、地理ベースのタイムゾーンを出力する場合、“JST”などのあいまいな略称は使わないようにしましょう。

データの入力
-------------

### 現在時刻の取得

現在時刻を取得して使うだけなら単純に済むことは多いですが、通信が関係する場合は「通信対象（たとえばブラウザ）が認識する時刻・タイムゾーン」と「今書いているコードが動く環境の時刻・タイムゾーン」のどちらを扱いたいのか・扱っているのかを明確にしましょう。<!--これじゃ分散システムの話っぽい…-->

### 外部データソースからの入力

自分で永続化したデータは設計したとおりに読み込めるはずですが、読み込むのはそればかりではありません。

読み込む時刻が文字列の場合、前述のISO 8601に従っていれば簡単ですが、そうでないこともあります。ありがちな問題としては、アメリカの慣習に従って年月日を「月日年」で並べたCSVのデータが来るかもしれません。

また、前述した“JST”のようなあいまいな略称が使われてしまうこともあります。その場合は決め打ちするしかありません。どうしても略称を読み込む必要がある場合は、「“JST”は“Asia/Tokyo”として扱う」など、対応関係を仕様として明確化しておきましょう。

JSR 310のZoneIdはおもにtzdb名を使ってインスタンス化するのですが、インスタンス化の際に別名のMapを与えることができます。たとえば“JST”を“Asia/Tokyo”に対応させるMapを用意しておけば、それを使って“Asia/Tokyo”と同等のZoneIdを“JST”から生成することもできます。

(^ まだ超過するようであればこの段落の後半、またはまるごと削ってください)

### ユーザからの入力

ユーザが過去や未来の時刻を手で入力する場合、その時刻がどの地域、どのオフセットのものかが問題になります。まずは要件からユーザの意図を検討しなければなりません。とくに未来の時刻を入力する場合、ユーザは前述のイベントの例のように「将来ずれるかもしれない現地時刻」を指定したいのか、「将来もずれない絶対時刻」を指定したいのか、要件によって異なるでしょう。

ユーザが想定するタイムゾーンを特定する方法はいくつか考えられます。大きく分けると、時刻と一緒に手で入力してもらう、事前にアカウントなどに設定しておいてもらう、ユーザが「今いる」タイムゾーンを使う、の3つになるでしょう。

手で入力してもらうのは煩雑ですが確実です。限定された「わかっている」ユーザが対象の場合や、間違いが許されない重要な設定の場合は、有力な選択肢になります。また、手入力以外を採用した場合でも、最後の手段として手で編集する余地を残す案もあります。

アカウントなどに設定しておいてもらう方法は、もちろんアカウントなどに設定を保存できるシステムであることが大前提です。そのうえで、ユーザが他のタイムゾーンに移動したときに、設定の追従を忘れる可能性も考慮に入れなくてはならないでしょう。手で入力をさせないまでも「今あなたが入力しようとしているのは東京時間です」とわかる表示をすると、間違いを減らせるかもしれません。

ユーザが「今いる」タイムゾーンを使うのは意外と厄介です。まず、ユーザが本当に今いる場所の時刻を意図しているのかは、自明ではありません。そして「今いる」タイムゾーンを取得する方法も技術的に確実ではありません。スマートフォンのアプリなどなら取得しやすいですが、とくにPCは場所を正確に反映しているとは限りません。

Webブラウザの場合はさらに厄介です。地理ベースのタイムゾーンを取得するブラウザAPIの状況は、まだ芳((かんば))しくありません。ネイティブと同程度の確実さで取得できるのは「現在のオフセット」だけです。現在のオフセットを使って、時刻の切り替わりをまたぐ過去や未来の時刻を解釈すると、当然おかしなことになってしまいます。

Time Zone Databaseの更新
-------------------

tzdbは新しい版が頻繁にリリースされます。古い版のtzdbを使っていると、地域によって時刻の解釈がおかしくなってしまい、それが致命的な問題を引き起こすこともあるでしょう。

ネイティブアプリケーションやライブラリの開発はtzdbのバージョン管理とは独立ですが、オンラインサービスの運用はそうもいきません。サモアのように大きな変更が直前に入ることがあると考えると、コーディング以外にtzdb更新の戦略もしっかり立てておかなければなりません。いま作っているソフトウェアがどこのtzdbを参照していて、なにを更新すればtzdbが更新されるのかを把握しておきましょう。

Javaで使われるtzdbはJava Runtimeの各バージョンに付属します。

<!--
リンク (あとで消す)

* https://qiita.com/dmikurube/items/15899ec9de643e91497c
* https://www.slideshare.net/khasunuma/jsr310-75403613
* https://www.slideshare.net/khasunuma/jsr310-2-75403948
* https://www.slideshare.net/khasunuma/jdk8-threeten-75404053
* https://www.slideshare.net/khasunuma/jsr310-timezone-75404253
* https://www.slideshare.net/khasunuma/jsr310-adjuster-75404274
* https://www.slideshare.net/khasunuma/jsr310-3-75404431
* https://www.slideshare.net/khasunuma/jsr310-4-75404462
* https://www.m3tech.blog/entry/timezone-handling
* https://quipper.hatenablog.com/entry/2016/12/08/090000
-->

Java 特有の話
==============

Java Runtimeとtzdb
-------------------

先に書いたとおり、Javaの場合はJava Runtimeにコンパイル済みのtzdbが付属するようになっています。Java Runtimeを更新すると、新しいtzdbもくっついてきて更新されます。Java自体は更新したくないけどtzdbだけ更新したい、という場合はTZUpdater [^3]などで対応できます。

[^3]: http://www.oracle.com/technetwork/jp/java/javase/tzupdater-readme-136440.html

tzdbがJavaの実行環境に付属するものであってJavaアプリケーションに付属するものではない、という点に注意しましょう。つまり、同じアプリケーションを動かしていても、ホストAのJava環境とホストBのJava環境でtzdbのバージョンが食い違うことがありえます。

タイムゾーンが関係するクラス（ZoneIdや、それを使ったZonedDateTimeなど）を使う場合、アプリケーションの更新・管理とともに、tzdbのバージョン管理も行う必要があります。

JSR 310：Date and Time API
---------------------------

JSR 310は日付・時刻を扱う新しいJava APIです。Java 8から追加されました。Java 6のころにStephen Colebourne氏が設計・実装したJoda-Timeという日付時刻ライブラリがあったのですが、このJoda-Timeをベースとして公式に再設計されたのがJSR 310です。古くからあるjava.util.Dateなどを完全に置き換えることを目標にしたようです。

時刻というのは、ここまで書いてきたようにそもそも複雑なものです。JSR 310はそれを忠実にモデル化しており、複雑になるのはある程度しかたのない面があります。その複雑さを中途半端に隠蔽してしまうと、意図した処理を書くのが余計にたいへんになりかねません。それでも、多くのクラスを不変クラスにするなど、複雑なモデルを扱いやすくする工夫は随所にされています。

### Unix time：Instant

Unix timeに相当する時間軸上の1点を表すのがInstantです。これはUnix timeとほぼ同じものの、少し異なる「Javaタイム・スケール」に従って、秒とナノ秒を用いて時刻を表します。

Javaタイム・スケールがUnix timeと異なるのはおもに閏秒の扱いです。詳細はInstantのJavadocに記述がありますが、現在のJavaタイム・スケールでは、1972年11月3日以降の時刻には前述のUTC-SLSが採用され、閏秒が導入される日の最後の1,000秒に希釈されます。この「ごまかし」が許容できる場合は、内部表現としてInstantを使うのは有力な選択肢になるでしょう。

(TODO: この段落↑と次の段落↓が、初校への変更が未反映のようです)

閏秒をそのまま扱いたい場合は、前述のThreeTen-Extraを使うことができます。こちらにはUtcInstantなどのクラスがあり、閏秒を含んだままUTCを扱えます。

### タイムゾーン：ZoneIdとZoneOffset

JSR 310のタイムゾーンは、すべてのタイムゾーンを表すZoneIdと、オフセットのみを表すサブクラスのZoneOffsetで表現されます。どちらも不変クラスで、インスタンスはZoneOffset.of("+09:00")、ZoneOffset.ofHours(9)、ZoneId.of("Asia/Tokyo")などとして作成します。

ZoneIdのインスタンスにはtzdbのエントリ（地理ベースのタイムゾーン）が対応していて、それぞれに定例・非定例の時刻切り替わりの情報が実装されています。いろいろなZoneIdインスタンスのZoneId#getRulesなどを呼んでみるとおもしろいでしょう。

地理ベースのタイムゾーンZoneIdとオフセットZoneOffsetが、別のクラスとして実装されているのがJSR 310の大事なところです。

### Local / Offset / Zoned

LocalDateTimeはタイムゾーン情報を持たない日付時刻、OffsetDateTimeはオフセット（ZoneOffset）のみをタイムゾーンとして持つ日付時刻、ZonedDateTimeは任意のタイムゾーン（ZoneId）を持つ日付時刻です。

どれが適切かは要件によって違ってくるでしょう。ここではJSR 310特有のポイントとしてOffsetDateTimeとZonedDateTimeの使い分けについて紹介します。

一見するとZonedDateTimeはOffsetDateTimeの上位互換で、ZonedDateTimeだけあればいいようにも思えます。しかし、地理的なタイムゾーンには時刻の切り替わりによる「存在しない時刻」「二重に存在する時刻」があったことを思い出すと、両方ある理由が見えてきます。

OffsetDateTimeはオフセットしか扱えない代わり、常にInstantに変換できます。逆にZonedDateTimeは地理ベースのタイムゾーンと時刻の切り替わりの計算ができる代わりに、「存在しない時刻」「二重に存在する時刻」を常に考慮しなければなりません。

これらが別のクラスとして設計されていることで、たとえばOffsetDateTimeなら「常にInstantにできる」ことを型で確認できるのです。逆にZonedDateTimeなら、計算の結果「存在しない時刻」「二重に存在する時刻」に突入してしまうときの対処が各種実装されており、それらを自分で使って細かな対応を実装していくことになります。

Java 7以前
-----------

JSR 310はJava 8以降のもので、残念ながらJava 7以前では使えません。JSR 310の大部分をJava 6/7向けにバックポートしたThreeTen-Backportというライブラリがあります。不幸にもまだJava 6/7しか使えない場合はそちらを使いましょう。

今から前述のJoda-Timeを使うよりはThreeTen-Backportのほうがいいでしょう。ThreeTen-Backportのリリース当時は「直近でJava 8に移行するのでなければJoda-Timeのがおすすめ」と言われていたのですが、今もJava 8にすら移行する予定がないとしたら、それ自体が問題です。

古いAPIのjava.util.Dateとjava.util.Calendarを使うのは勧められません。

まとめ
=======

時刻やタイムゾーンというのは簡単に見えるようで、十分に複雑な概念です。ソフトウェアに関してだけでも扱い方は何通りも考えられ、それぞれ利点と欠点があります。どういうときは簡単なやり方に逃げられるのか、逃げるべきか、どうしようもないときの次善策など、本章がその判断の一助となれば幸いです。

年初にQiitaにタイムゾーンの解説記事[^2]を書いたところ、その夏にこんな事態になり、本章はその記事を本誌でまとめなおす機会をいただいたものです。本章に誤りや不正確な記述を見つけたら、ぜひQiitaのほうにコメントをください。そちらは適宜更新していきます。

[^2]: 「タイムゾーン呪いの書」 https://qiita.com/dmikurube/items/15899ec9de643e91497c
